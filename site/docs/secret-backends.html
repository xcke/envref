<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Secret Backends — envref docs</title>
  <meta name="description" content="Configure secret backends: OS keychain, local vault, 1Password, AWS SSM, HashiCorp Vault, OCI Vault, and custom plugins.">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600;700&family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="doc.css">
</head>
<body>
  <!-- Nav -->
  <nav>
    <div class="nav-inner">
      <a href="../index.html" class="nav-logo">envref<span> /</span></a>
      <ul class="nav-links">
        <li><a href="../index.html#features">Features</a></li>
        <li><a href="../index.html#backends">Backends</a></li>
        <li><a href="../index.html#commands">Commands</a></li>
        <li><a href="../index.html#install">Install</a></li>
        <li><a href="../index.html#docs">Docs</a></li>
      </ul>
      <a href="https://github.com/xcke/envref" class="nav-github">
        <svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor"><path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"/></svg>
        GitHub
      </a>
    </div>
  </nav>

  <div class="doc-layout">
    <aside class="doc-sidebar">
      <a href="../index.html" class="back-link">&larr; Home</a>
      <h4>Documentation</h4>
      <ul>
        <li><a href="getting-started.html">Getting Started</a></li>
        <li class="active"><a href="secret-backends.html">Secret Backends</a></li>
        <li><a href="profiles.html">Profiles</a></li>
        <li><a href="direnv-integration.html">direnv Integration</a></li>
      </ul>
    </aside>

    <main class="doc-content">
      <h1>Secret Backends</h1>
      <p class="doc-lead">envref resolves <code>ref://</code> secret references through configurable backends. Backends are tried in order — the first one that has the requested key wins.</p>

      <h2>Built-in backends</h2>
      <p>envref ships with six built-in backends plus a plugin system for custom integrations:</p>

      <table>
        <thead>
          <tr>
            <th>Backend</th>
            <th>Type</th>
            <th>Storage</th>
            <th>Encryption</th>
            <th>Setup</th>
            <th>Use case</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>Keychain</td>
            <td><code>keychain</code></td>
            <td>OS keychain (macOS Keychain, Linux Secret Service, Windows Credential Manager)</td>
            <td>OS-managed</td>
            <td>None (default)</td>
            <td>Development machines with a desktop environment</td>
          </tr>
          <tr>
            <td>Vault</td>
            <td><code>vault</code></td>
            <td>Local SQLite at <code>~/.config/envref/vault.db</code></td>
            <td>age scrypt per-value</td>
            <td><code>envref vault init</code></td>
            <td>Headless servers, containers, CI</td>
          </tr>
          <tr>
            <td>1Password</td>
            <td><code>1password</code></td>
            <td>1Password vault via <code>op</code> CLI</td>
            <td>1Password-managed</td>
            <td><code>op signin</code></td>
            <td>Teams using 1Password</td>
          </tr>
          <tr>
            <td>AWS SSM</td>
            <td><code>aws-ssm</code></td>
            <td>AWS Systems Manager Parameter Store</td>
            <td>AWS KMS</td>
            <td>AWS CLI configured</td>
            <td>AWS-based infrastructure</td>
          </tr>
          <tr>
            <td>HashiCorp Vault</td>
            <td><code>hashicorp-vault</code></td>
            <td>HashiCorp Vault KV v2 secrets engine</td>
            <td>Vault-managed</td>
            <td><code>vault login</code></td>
            <td>Enterprise secret management</td>
          </tr>
          <tr>
            <td>OCI Vault</td>
            <td><code>oci-vault</code></td>
            <td>Oracle Cloud Infrastructure Vault</td>
            <td>OCI-managed</td>
            <td>OCI CLI configured</td>
            <td>Oracle Cloud workloads</td>
          </tr>
          <tr>
            <td>Plugin</td>
            <td><code>plugin</code></td>
            <td>Custom (external executable)</td>
            <td>Custom</td>
            <td>Plugin on <code>$PATH</code></td>
            <td>Custom or third-party secret stores</td>
          </tr>
        </tbody>
      </table>

      <hr>

      <h2>Keychain backend</h2>
      <p>The keychain backend uses your operating system's native credential store via <a href="https://github.com/zalando/go-keyring">go-keyring</a>:</p>
      <ul>
        <li><strong>macOS</strong>: Keychain Access</li>
        <li><strong>Linux</strong>: Secret Service API (GNOME Keyring, KWallet)</li>
        <li><strong>Windows</strong>: Windows Credential Manager</li>
      </ul>
      <p>No configuration is needed — it works out of the box on systems with a desktop environment. Secrets are stored under the service name <code>envref</code> with namespaced keys.</p>

      <p><strong>Configuration:</strong></p>
<pre><code>backends:
  - name: keychain
    type: keychain</code></pre>

      <p>No additional options. This is the default backend when no <code>backends</code> section is present in <code>.envref.yaml</code>.</p>

      <p><strong>Example — store and retrieve a secret:</strong></p>
<pre><code># Store a database URL in the OS keychain
envref secret set database_url --value "postgres://user:pass@localhost/mydb"

# Retrieve it
envref secret get database_url
# postgres://user:pass@localhost/mydb

# Reference it in .env
echo 'DATABASE_URL=ref://secrets/database_url' &gt;&gt; .env

# Resolve
envref resolve
# DATABASE_URL=postgres://user:pass@localhost/mydb</code></pre>

      <hr>

      <h2>Vault backend</h2>
      <p>The vault backend is a local encrypted store for environments where the OS keychain is unavailable (SSH servers, Docker containers, CI runners).</p>
      <p>Each secret is individually encrypted using <a href="https://age-encryption.org/">age</a> with scrypt-based key derivation from a master passphrase. Secrets are stored in a SQLite database at <code>~/.config/envref/vault.db</code>.</p>

      <p><strong>Configuration:</strong></p>
<pre><code>backends:
  - name: vault
    type: vault
    config:
      path: ~/.config/envref/vault.db   # optional, this is the default</code></pre>

      <table>
        <thead>
          <tr>
            <th>Option</th>
            <th>Description</th>
            <th>Default</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><code>path</code></td>
            <td>Path to the SQLite database file</td>
            <td><code>~/.config/envref/vault.db</code></td>
          </tr>
        </tbody>
      </table>

      <p>The passphrase is resolved in order:</p>
      <ol>
        <li><code>ENVREF_VAULT_PASSPHRASE</code> environment variable</li>
        <li>Interactive terminal prompt</li>
      </ol>

      <p><strong>Example — set up vault for a CI pipeline:</strong></p>
<pre><code># Initialize the vault (interactive — prompts for passphrase)
envref vault init

# Or initialize non-interactively
ENVREF_VAULT_PASSPHRASE=my-secret-passphrase envref vault init

# Store secrets
envref secret set api_key --backend vault --value "sk-abc123"
envref secret set db_password --backend vault

# In CI, set the passphrase via environment variable
export ENVREF_VAULT_PASSPHRASE="my-secret-passphrase"
envref resolve</code></pre>

      <p><strong>Example — vault lifecycle management:</strong></p>
<pre><code># Lock the vault (prevents all access)
envref vault lock

# Unlock the vault
envref vault unlock

# Export all secrets as JSON (plaintext — handle with care)
envref vault export &gt; vault-backup.json

# Import secrets from a backup
envref vault import &lt; vault-backup.json</code></pre>

      <hr>

      <h2>1Password backend</h2>
      <p>The 1Password backend delegates secret storage to <a href="https://1password.com/">1Password</a> via the <code>op</code> CLI (v2+). Secrets are stored as "Secure Note" items in the configured vault, with the item title as the secret key and the value in the <code>notesPlain</code> field.</p>

      <p><strong>Prerequisites:</strong></p>
      <ol>
        <li>
          <p>Install the <a href="https://developer.1password.com/docs/cli/get-started/">1Password CLI</a>:</p>
<pre><code>brew install 1password-cli</code></pre>
        </li>
        <li>
          <p>Sign in to your account:</p>
<pre><code>op signin</code></pre>
        </li>
        <li>
          <p>(Optional) Enable <a href="https://developer.1password.com/docs/cli/get-started/#turn-on-biometric-unlock">biometric unlock</a> for passwordless CLI access.</p>
        </li>
      </ol>

      <p><strong>Configuration:</strong></p>
<pre><code>backends:
  - name: op
    type: 1password
    config:
      vault: Personal              # 1Password vault name (default: "Personal")
      account: my.1password.com    # optional: account shorthand or URL
      command: /usr/local/bin/op   # optional: path to op CLI</code></pre>

      <table>
        <thead>
          <tr>
            <th>Option</th>
            <th>Description</th>
            <th>Default</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><code>vault</code></td>
            <td>1Password vault name</td>
            <td><code>Personal</code></td>
          </tr>
          <tr>
            <td><code>account</code></td>
            <td>Account shorthand or URL (for multi-account setups)</td>
            <td><em>(none)</em></td>
          </tr>
          <tr>
            <td><code>command</code></td>
            <td>Path to the <code>op</code> CLI executable</td>
            <td><code>op</code> (found via <code>$PATH</code>)</td>
          </tr>
        </tbody>
      </table>

      <p><strong>Example — team setup with 1Password:</strong></p>
<pre><code># .envref.yaml
project: my-saas-app

backends:
  - name: op
    type: 1password
    config:
      vault: Engineering
      account: mycompany.1password.com</code></pre>

<pre><code># Sign in to 1Password
op signin

# Store secrets via envref (stored in the "Engineering" vault)
envref secret set stripe_api_key --value "sk_live_abc123"
envref secret set sendgrid_key --value "SG.xyz789"

# Reference in .env
echo 'STRIPE_API_KEY=ref://secrets/stripe_api_key' &gt;&gt; .env
echo 'SENDGRID_KEY=ref://secrets/sendgrid_key' &gt;&gt; .env

# Resolve — fetches from 1Password
envref resolve
# STRIPE_API_KEY=sk_live_abc123
# SENDGRID_KEY=SG.xyz789</code></pre>

      <hr>

      <h2>AWS SSM Parameter Store backend</h2>
      <p>The AWS SSM backend stores secrets in <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/systems-manager-parameter-store.html">AWS Systems Manager Parameter Store</a> as SecureString parameters, encrypted with AWS KMS. It delegates all operations to the <code>aws</code> CLI.</p>

      <p><strong>Prerequisites:</strong></p>
      <ol>
        <li>
          <p>Install the <a href="https://docs.aws.amazon.com/cli/latest/userguide/getting-started-install.html">AWS CLI v2</a>:</p>
<pre><code>brew install awscli</code></pre>
        </li>
        <li>
          <p>Configure credentials:</p>
<pre><code>aws configure
# Or use SSO: aws sso login --profile myprofile</code></pre>
        </li>
        <li>
          <p>Ensure the IAM role/user has <code>ssm:GetParameter</code>, <code>ssm:PutParameter</code>, <code>ssm:DeleteParameter</code>, and <code>ssm:GetParametersByPath</code> permissions.</p>
        </li>
      </ol>

      <p><strong>Configuration:</strong></p>
<pre><code>backends:
  - name: ssm
    type: aws-ssm
    config:
      prefix: /myapp/prod        # parameter name prefix (default: "/envref")
      region: us-east-1           # optional: AWS region
      profile: prod-account       # optional: AWS CLI named profile
      command: /usr/local/bin/aws # optional: path to aws CLI</code></pre>

      <table>
        <thead>
          <tr>
            <th>Option</th>
            <th>Description</th>
            <th>Default</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><code>prefix</code></td>
            <td>Parameter name prefix (keys stored as <code>&lt;prefix&gt;/&lt;key&gt;</code>)</td>
            <td><code>/envref</code></td>
          </tr>
          <tr>
            <td><code>region</code></td>
            <td>AWS region for Parameter Store</td>
            <td><em>(AWS CLI default)</em></td>
          </tr>
          <tr>
            <td><code>profile</code></td>
            <td>AWS CLI named profile</td>
            <td><em>(AWS CLI default)</em></td>
          </tr>
          <tr>
            <td><code>command</code></td>
            <td>Path to the <code>aws</code> CLI executable</td>
            <td><code>aws</code> (found via <code>$PATH</code>)</td>
          </tr>
        </tbody>
      </table>

      <p>Secrets are stored as SecureString parameters at <code>&lt;prefix&gt;/&lt;key&gt;</code>. For example, with <code>prefix: /myapp/prod</code>, a secret named <code>api_key</code> is stored at <code>/myapp/prod/api_key</code>.</p>

      <p><strong>Example — production secrets in AWS:</strong></p>
<pre><code># .envref.yaml
project: my-api

backends:
  - name: ssm
    type: aws-ssm
    config:
      prefix: /my-api/production
      region: us-west-2
      profile: production</code></pre>

<pre><code># Store secrets (written to SSM Parameter Store as SecureString)
envref secret set database_url --backend ssm \
  --value "postgres://admin:s3cret@rds.amazonaws.com:5432/mydb"
envref secret set jwt_secret --backend ssm

# List stored secrets
envref secret list --backend ssm
# database_url
# jwt_secret

# Use in .env
# DATABASE_URL=ref://secrets/database_url
# JWT_SECRET=ref://secrets/jwt_secret

# Resolve (uses AWS credentials to fetch from SSM)
envref resolve</code></pre>

      <p><strong>Example — multi-environment with profiles:</strong></p>
<pre><code># .envref.yaml
project: my-api

backends:
  - name: ssm-staging
    type: aws-ssm
    config:
      prefix: /my-api/staging
      region: us-west-2
      profile: staging
  - name: ssm-prod
    type: aws-ssm
    config:
      prefix: /my-api/production
      region: us-west-2
      profile: production</code></pre>

<pre><code># Store per-environment secrets
envref secret set api_key --backend ssm-staging --value "sk_test_abc"
envref secret set api_key --backend ssm-prod --value "sk_live_xyz"

# Resolve with specific backend
envref secret get api_key --backend ssm-staging
# sk_test_abc</code></pre>

      <hr>

      <h2>HashiCorp Vault backend</h2>
      <p>The HashiCorp Vault backend stores secrets in a <a href="https://www.vaultproject.io/">HashiCorp Vault</a> KV v2 secrets engine. It delegates all operations to the <code>vault</code> CLI.</p>

      <p><strong>Prerequisites:</strong></p>
      <ol>
        <li>
          <p>Install the <a href="https://developer.hashicorp.com/vault/install">Vault CLI</a>:</p>
<pre><code>brew install hashicorp/tap/vault</code></pre>
        </li>
        <li>
          <p>Authenticate with your Vault server:</p>
<pre><code>export VAULT_ADDR="https://vault.example.com:8200"
vault login</code></pre>
        </li>
        <li>
          <p>Ensure you have read/write access to the target KV v2 mount and path.</p>
        </li>
      </ol>

      <p><strong>Configuration:</strong></p>
<pre><code>backends:
  - name: hcvault
    type: hashicorp-vault
    config:
      mount: secret              # KV v2 mount path (default: "secret")
      prefix: envref             # path prefix within mount (default: "envref")
      addr: https://vault.example.com:8200  # optional: Vault server URL
      namespace: admin           # optional: Vault Enterprise namespace
      token: hvs.abc123         # optional: auth token (prefer VAULT_TOKEN env var)
      command: /usr/local/bin/vault  # optional: path to vault CLI</code></pre>

      <table>
        <thead>
          <tr>
            <th>Option</th>
            <th>Description</th>
            <th>Default</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><code>mount</code></td>
            <td>KV v2 secrets engine mount path</td>
            <td><code>secret</code></td>
          </tr>
          <tr>
            <td><code>prefix</code></td>
            <td>Path prefix within the mount (keys stored at <code>&lt;mount&gt;/data/&lt;prefix&gt;/&lt;key&gt;</code>)</td>
            <td><code>envref</code></td>
          </tr>
          <tr>
            <td><code>addr</code></td>
            <td>Vault server URL (can also use <code>VAULT_ADDR</code> env var)</td>
            <td><em>(vault CLI default)</em></td>
          </tr>
          <tr>
            <td><code>namespace</code></td>
            <td>Vault Enterprise namespace (can also use <code>VAULT_NAMESPACE</code> env var)</td>
            <td><em>(none)</em></td>
          </tr>
          <tr>
            <td><code>token</code></td>
            <td>Authentication token (can also use <code>VAULT_TOKEN</code> env var)</td>
            <td><em>(none)</em></td>
          </tr>
          <tr>
            <td><code>command</code></td>
            <td>Path to the <code>vault</code> CLI executable</td>
            <td><code>vault</code> (found via <code>$PATH</code>)</td>
          </tr>
        </tbody>
      </table>

      <p>Secrets are stored as individual KV v2 entries at <code>&lt;mount&gt;/data/&lt;prefix&gt;/&lt;key&gt;</code> with the value in a <code>value</code> field.</p>

      <p><strong>Example — centralized secret management:</strong></p>
<pre><code># .envref.yaml
project: payment-service

backends:
  - name: hcvault
    type: hashicorp-vault
    config:
      mount: secret
      prefix: payment-service
      addr: https://vault.internal:8200</code></pre>

<pre><code># Authenticate (typically via CI token or app role)
export VAULT_ADDR="https://vault.internal:8200"
vault login -method=token token=hvs.abc123

# Store secrets
envref secret set stripe_key --backend hcvault --value "sk_live_abc123"
envref secret set webhook_secret --backend hcvault

# Reference in .env
# STRIPE_KEY=ref://secrets/stripe_key
# WEBHOOK_SECRET=ref://secrets/webhook_secret

# Resolve
envref resolve</code></pre>

      <p><strong>Example — Vault Enterprise with namespaces:</strong></p>
<pre><code>backends:
  - name: hcvault
    type: hashicorp-vault
    config:
      mount: kv
      prefix: team-alpha/myapp
      addr: https://vault.corp.example.com:8200
      namespace: engineering/team-alpha</code></pre>

      <hr>

      <h2>OCI Vault backend</h2>
      <p>The OCI Vault backend stores secrets in <a href="https://www.oracle.com/security/cloud-security/key-management/">Oracle Cloud Infrastructure Vault</a>. It delegates all operations to the <code>oci</code> CLI.</p>

      <p><strong>Prerequisites:</strong></p>
      <ol>
        <li>
          <p>Install the <a href="https://docs.oracle.com/en-us/iaas/Content/API/SDKDocs/cliinstall.htm">OCI CLI</a>:</p>
<pre><code>brew install oci-cli
# Or: pip install oci-cli</code></pre>
        </li>
        <li>
          <p>Configure the CLI:</p>
<pre><code>oci setup config</code></pre>
        </li>
        <li>
          <p>Ensure you have a Vault, Compartment, and Master Encryption Key provisioned in OCI.</p>
        </li>
        <li>
          <p>Ensure your IAM policy grants <code>manage secret-family</code> permissions in the target compartment.</p>
        </li>
      </ol>

      <p><strong>Configuration:</strong></p>
<pre><code>backends:
  - name: oci
    type: oci-vault
    config:
      vault_id: ocid1.vault.oc1.iad.abcd1234...         # required: vault OCID
      compartment_id: ocid1.compartment.oc1..abcd5678... # required: compartment OCID
      key_id: ocid1.key.oc1.iad.abcd9012...              # required: master encryption key OCID
      profile: DEFAULT                                    # optional: OCI CLI config profile
      command: /usr/local/bin/oci                         # optional: path to oci CLI</code></pre>

      <table>
        <thead>
          <tr>
            <th>Option</th>
            <th>Description</th>
            <th>Default</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><code>vault_id</code></td>
            <td>OCI Vault OCID</td>
            <td><em>(required)</em></td>
          </tr>
          <tr>
            <td><code>compartment_id</code></td>
            <td>OCI Compartment OCID</td>
            <td><em>(required)</em></td>
          </tr>
          <tr>
            <td><code>key_id</code></td>
            <td>Master Encryption Key OCID (required for storing secrets)</td>
            <td><em>(required)</em></td>
          </tr>
          <tr>
            <td><code>profile</code></td>
            <td>OCI CLI configuration profile name</td>
            <td><em>(OCI CLI default)</em></td>
          </tr>
          <tr>
            <td><code>command</code></td>
            <td>Path to the <code>oci</code> CLI executable</td>
            <td><code>oci</code> (found via <code>$PATH</code>)</td>
          </tr>
        </tbody>
      </table>

      <p>Secret values are base64-encoded before storage. Deletion in OCI is scheduled (not immediate) with a minimum pending period.</p>

      <p><strong>Example — Oracle Cloud workload:</strong></p>
<pre><code># .envref.yaml
project: oci-microservice

backends:
  - name: oci
    type: oci-vault
    config:
      vault_id: ocid1.vault.oc1.iad.b5re4wdnaabc.abuwcljr...
      compartment_id: ocid1.compartment.oc1..aaaaaaa...
      key_id: ocid1.key.oc1.iad.b5re4wdnaabc.abuwcljr...</code></pre>

<pre><code># Store secrets
envref secret set db_password --backend oci --value "oracle-secret-123"

# Reference in .env
# DB_PASSWORD=ref://secrets/db_password

# Resolve
envref resolve</code></pre>

      <hr>

      <h2>Plugin backend</h2>
      <p>The plugin backend enables integration with any secret store by delegating operations to an external executable. Plugins communicate via a simple JSON-over-stdin/stdout protocol.</p>

      <p><strong>Plugin discovery:</strong></p>
      <p>Plugins are found in one of two ways:</p>
      <ol>
        <li><strong>By convention</strong>: an executable named <code>envref-backend-&lt;name&gt;</code> on <code>$PATH</code></li>
        <li><strong>By explicit path</strong>: the <code>command</code> option in <code>.envref.yaml</code></li>
      </ol>

      <p><strong>Configuration:</strong></p>
<pre><code>backends:
  - name: my-store
    type: plugin
    config:
      command: /usr/local/bin/envref-backend-my-store  # optional if on $PATH</code></pre>

      <table>
        <thead>
          <tr>
            <th>Option</th>
            <th>Description</th>
            <th>Default</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><code>command</code></td>
            <td>Path to the plugin executable</td>
            <td><code>envref-backend-&lt;name&gt;</code> (found via <code>$PATH</code>)</td>
          </tr>
        </tbody>
      </table>

      <h3>Plugin protocol</h3>
      <p>The plugin receives a JSON request on stdin and must write a JSON response to stdout. Each invocation handles a single operation.</p>

      <p><strong>Request format:</strong></p>
<pre><code>{
  "operation": "get",
  "key": "api_key"
}</code></pre>

      <table>
        <thead>
          <tr>
            <th>Field</th>
            <th>Type</th>
            <th>Description</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><code>operation</code></td>
            <td>string</td>
            <td>One of: <code>get</code>, <code>set</code>, <code>delete</code>, <code>list</code></td>
          </tr>
          <tr>
            <td><code>key</code></td>
            <td>string</td>
            <td>Secret key name (present for <code>get</code>, <code>set</code>, <code>delete</code>)</td>
          </tr>
          <tr>
            <td><code>value</code></td>
            <td>string</td>
            <td>Secret value (present for <code>set</code> only)</td>
          </tr>
        </tbody>
      </table>

      <p><strong>Response format:</strong></p>
<pre><code>{
  "value": "sk-abc123"
}</code></pre>

      <table>
        <thead>
          <tr>
            <th>Field</th>
            <th>Type</th>
            <th>Description</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><code>value</code></td>
            <td>string</td>
            <td>Secret value (returned by <code>get</code>)</td>
          </tr>
          <tr>
            <td><code>keys</code></td>
            <td>[]string</td>
            <td>List of key names (returned by <code>list</code>)</td>
          </tr>
          <tr>
            <td><code>error</code></td>
            <td>string</td>
            <td>Error message (present on failure)</td>
          </tr>
        </tbody>
      </table>

      <p><strong>Error handling:</strong> If a key is not found, the plugin should return an error message containing "not found" (case-insensitive). envref interprets this as <code>ErrNotFound</code> and continues to the next backend in the fallback chain.</p>

      <h3>Example — writing a plugin in Bash</h3>
<pre><code>#!/usr/bin/env bash
# envref-backend-mystore — example plugin that stores secrets in a flat file
set -euo pipefail

STORE_FILE="${HOME}/.mystore/secrets.json"
mkdir -p "$(dirname "$STORE_FILE")"
[ -f "$STORE_FILE" ] || echo '{}' &gt; "$STORE_FILE"

REQUEST=$(cat)
OP=$(echo "$REQUEST" | jq -r '.operation')
KEY=$(echo "$REQUEST" | jq -r '.key // empty')

case "$OP" in
  get)
    VALUE=$(jq -r --arg k "$KEY" '.[$k] // empty' "$STORE_FILE")
    if [ -z "$VALUE" ]; then
      echo '{"error": "not found"}'
    else
      echo "{\"value\": $(echo "$VALUE" | jq -Rs .)}"
    fi
    ;;
  set)
    VALUE=$(echo "$REQUEST" | jq -r '.value')
    jq --arg k "$KEY" --arg v "$VALUE" '. + {($k): $v}' "$STORE_FILE" &gt; "${STORE_FILE}.tmp"
    mv "${STORE_FILE}.tmp" "$STORE_FILE"
    echo '{}'
    ;;
  delete)
    jq --arg k "$KEY" 'del(.[$k])' "$STORE_FILE" &gt; "${STORE_FILE}.tmp"
    mv "${STORE_FILE}.tmp" "$STORE_FILE"
    echo '{}'
    ;;
  list)
    KEYS=$(jq '[keys[]]' "$STORE_FILE")
    echo "{\"keys\": $KEYS}"
    ;;
esac</code></pre>

<pre><code># Make it executable and place on $PATH
chmod +x envref-backend-mystore
mv envref-backend-mystore /usr/local/bin/</code></pre>

<pre><code># .envref.yaml
backends:
  - name: mystore
    type: plugin</code></pre>

      <h3>Example — writing a plugin in Python</h3>
<pre><code>#!/usr/bin/env python3
"""envref-backend-redis — plugin that stores secrets in Redis."""
import json
import sys
import redis

r = redis.Redis(host="localhost", port=6379, db=0, decode_responses=True)
PREFIX = "envref:"

request = json.loads(sys.stdin.read())
op = request["operation"]
key = request.get("key", "")

if op == "get":
    value = r.get(f"{PREFIX}{key}")
    if value is None:
        print(json.dumps({"error": "not found"}))
    else:
        print(json.dumps({"value": value}))
elif op == "set":
    r.set(f"{PREFIX}{key}", request["value"])
    print(json.dumps({}))
elif op == "delete":
    r.delete(f"{PREFIX}{key}")
    print(json.dumps({}))
elif op == "list":
    keys = [k.removeprefix(PREFIX) for k in r.keys(f"{PREFIX}*")]
    print(json.dumps({"keys": keys}))</code></pre>

      <hr>

      <h2>Configuration</h2>
      <p>Backends are configured in <code>.envref.yaml</code>:</p>
<pre><code>project: my-app

backends:
  - name: keychain
    type: keychain
  - name: vault
    type: vault
    config:
      path: ~/.config/envref/vault.db</code></pre>

      <p>The <code>backends</code> list defines the fallback chain — backends are tried in order when resolving a <code>ref://</code> reference. If the first backend doesn't have the key, the next one is tried.</p>

      <h3>Default configuration</h3>
      <p>If no <code>backends</code> section is present in <code>.envref.yaml</code>, envref uses the keychain backend by default.</p>

      <h3>Multi-backend configuration</h3>
      <p>You can configure multiple backends for different use cases. Common patterns:</p>

      <p><strong>Development with cloud fallback:</strong></p>
<pre><code>project: my-app

backends:
  - name: keychain
    type: keychain
  - name: ssm
    type: aws-ssm
    config:
      prefix: /my-app/shared
      region: us-west-2</code></pre>

      <p>Secrets in the OS keychain are found first. If a key isn't in the keychain (e.g., shared infrastructure secrets), SSM is checked next.</p>

      <p><strong>Team with 1Password and local vault fallback:</strong></p>
<pre><code>project: my-app

backends:
  - name: op
    type: 1password
    config:
      vault: Engineering
  - name: vault
    type: vault</code></pre>

      <p>Team secrets live in 1Password. Developer-specific overrides go in the local vault.</p>

      <p><strong>Full enterprise stack:</strong></p>
<pre><code>project: my-app

backends:
  - name: keychain
    type: keychain
  - name: hcvault
    type: hashicorp-vault
    config:
      mount: secret
      prefix: my-app
      addr: https://vault.internal:8200
  - name: ssm
    type: aws-ssm
    config:
      prefix: /shared/secrets
      region: us-east-1</code></pre>

      <hr>

      <h2>Setting up the vault</h2>

      <h3>Initialize</h3>
<pre><code>envref vault init</code></pre>

      <p>This creates the SQLite database and sets up the encryption. You'll be prompted to create a master passphrase (with confirmation).</p>

      <p>For non-interactive initialization (CI/scripts):</p>
<pre><code>ENVREF_VAULT_PASSPHRASE=your-passphrase envref vault init</code></pre>

      <h3>Lock and unlock</h3>
      <p>The vault can be locked to prevent all secret access:</p>
<pre><code># Lock the vault (requires passphrase verification)
envref vault lock

# Unlock the vault (requires passphrase verification)
envref vault unlock</code></pre>

      <p>Lock state persists across CLI invocations. When locked, all secret get/set/delete/list operations against the vault backend will fail.</p>

      <hr>

      <h2>How secret lookup works</h2>

      <h3>Namespace format</h3>
      <p>Secrets are stored with a project namespace to prevent collisions between projects:</p>
<pre><code>Without profile:  &lt;project&gt;/&lt;key&gt;
With profile:     &lt;project&gt;/&lt;profile&gt;/&lt;key&gt;</code></pre>

      <p>For example, with <code>project: my-app</code> in <code>.envref.yaml</code>:</p>
<pre><code>envref secret set api_key              -&gt; stored as: my-app/api_key
envref secret set api_key --profile staging -&gt; stored as: my-app/staging/api_key</code></pre>

      <h3>Resolution order</h3>
      <p>When <code>envref resolve</code> encounters a <code>ref://secrets/api_key</code> reference:</p>
      <ol>
        <li><strong>Parse</strong> the <code>ref://</code> URI to extract the key name</li>
        <li><strong>Try each backend</strong> in order (as configured in <code>backends</code>)</li>
        <li><strong>With profile</strong>: try <code>&lt;project&gt;/&lt;profile&gt;/&lt;key&gt;</code> first, fall back to <code>&lt;project&gt;/&lt;key&gt;</code></li>
        <li><strong>Without profile</strong>: look up <code>&lt;project&gt;/&lt;key&gt;</code> directly</li>
        <li><strong>First hit wins</strong> — stop at the first backend that returns a value</li>
      </ol>

      <h3>Caching</h3>
      <p>During a single <code>envref resolve</code> call, resolved values are cached in memory to avoid hitting the backend multiple times for the same key. The cache is not persisted between invocations.</p>

      <hr>

      <h2>Storing secrets</h2>

      <h3>Interactive mode</h3>
<pre><code>envref secret set database_url
# Enter secret value: (hidden input)</code></pre>

      <h3>Non-interactive mode</h3>
<pre><code>envref secret set database_url --value "postgres://user:pass@host/db"</code></pre>

      <h3>Specifying a backend</h3>
      <p>By default, secrets are stored in the first configured backend. Use <code>--backend</code> to target a specific one:</p>
<pre><code>envref secret set api_key --backend vault
envref secret set api_key --backend ssm
envref secret set api_key --backend hcvault</code></pre>

      <h3>Generating random secrets</h3>
<pre><code># Default: 32 characters, alphanumeric
envref secret generate session_secret

# Custom length and charset
envref secret generate api_key --length 64 --charset hex

# Print the generated value
envref secret generate api_key --print</code></pre>

      <p>Available character sets:</p>

      <table>
        <thead>
          <tr>
            <th>Charset</th>
            <th>Characters</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><code>alphanumeric</code> (default)</td>
            <td>a-z, A-Z, 0-9</td>
          </tr>
          <tr>
            <td><code>ascii</code></td>
            <td>alphanumeric + common symbols</td>
          </tr>
          <tr>
            <td><code>hex</code></td>
            <td>0-9, a-f</td>
          </tr>
          <tr>
            <td><code>base64</code></td>
            <td>standard base64 encoding</td>
          </tr>
        </tbody>
      </table>

      <p>Length range: 1-1024 characters. Uses cryptographic RNG (<code>crypto/rand</code>).</p>

      <hr>

      <h2>Managing secrets</h2>

      <h3>Retrieve a secret</h3>
<pre><code>envref secret get api_key</code></pre>

      <p>With profile scope:</p>
<pre><code>envref secret get api_key --profile staging</code></pre>

      <p>Profile lookup tries the profile-scoped key first, then falls back to the project-scoped key.</p>

      <h3>List secrets</h3>
<pre><code># List all project secrets
envref secret list

# List profile-scoped secrets
envref secret list --profile staging</code></pre>

      <p>Lists key names only — values are never printed by <code>list</code>.</p>

      <h3>Delete a secret</h3>
<pre><code>envref secret delete api_key
# Confirm deletion? (y/N)

# Skip confirmation
envref secret delete api_key --force</code></pre>

      <h3>Copy between projects</h3>
<pre><code>envref secret copy api_key --from other-project</code></pre>

      <p>This reads <code>other-project/api_key</code> and writes it to <code>&lt;current-project&gt;/api_key</code>.</p>

      <p>Copy with profile scopes:</p>
<pre><code>envref secret copy api_key --from other-project --from-profile production --profile staging</code></pre>

      <h3>Rotate a secret</h3>
<pre><code># Generate a new random value, archive the old one
envref secret rotate api_key

# Keep more history entries (default: 5)
envref secret rotate api_key --keep 10</code></pre>

      <p>Rotation generates a new random value, stores it as the current value, and archives the old value as <code>&lt;key&gt;.__history.&lt;N&gt;</code>.</p>

      <h3>Share a secret</h3>
<pre><code># Encrypt a secret for a specific recipient using their age public key
envref secret share api_key --to age1ql3z7hjy54pw3hyww5ayyfg7zqgvc7w3j2elw8zmrj2kg5sfn9aqmcac8p

# Read the recipient's public key from a file
envref secret share api_key --to-file recipient.pub</code></pre>

      <p>The output is ASCII-armored age-encrypted ciphertext that only the recipient can decrypt.</p>

      <hr>

      <h2>Using ref:// in .env files</h2>
      <p>Reference syntax:</p>
<pre><code># Simple secret reference
API_KEY=ref://secrets/api_key

# Variable interpolation works alongside references
DATABASE_URL=ref://secrets/database_url
DB_DISPLAY=${DATABASE_URL}

# Nested references (resolved in a second pass)
FULL_URL=postgres://${ref://secrets/db_user}:${ref://secrets/db_pass}@localhost/app</code></pre>

      <p>The <code>ref://secrets/&lt;key&gt;</code> format is the standard reference syntax. The <code>secrets</code> segment indicates the secret backend system.</p>

      <hr>

      <h2>Choosing a backend</h2>

      <table>
        <thead>
          <tr>
            <th>Scenario</th>
            <th>Recommended backend</th>
            <th>Why</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>Local development with desktop</td>
            <td><code>keychain</code> (default)</td>
            <td>Zero setup, OS-native security</td>
          </tr>
          <tr>
            <td>Headless server / SSH</td>
            <td><code>vault</code></td>
            <td>No desktop environment needed</td>
          </tr>
          <tr>
            <td>Docker container</td>
            <td><code>vault</code> with <code>ENVREF_VAULT_PASSPHRASE</code></td>
            <td>Portable, single-file store</td>
          </tr>
          <tr>
            <td>CI/CD pipeline</td>
            <td><code>vault</code> or <code>aws-ssm</code></td>
            <td>Non-interactive, scriptable</td>
          </tr>
          <tr>
            <td>Team using 1Password</td>
            <td><code>1password</code></td>
            <td>Shared vaults, biometric unlock</td>
          </tr>
          <tr>
            <td>AWS infrastructure</td>
            <td><code>aws-ssm</code></td>
            <td>Native integration, IAM-based access</td>
          </tr>
          <tr>
            <td>Enterprise with HashiCorp Vault</td>
            <td><code>hashicorp-vault</code></td>
            <td>Centralized policy and audit</td>
          </tr>
          <tr>
            <td>Oracle Cloud workloads</td>
            <td><code>oci-vault</code></td>
            <td>OCI-native key management</td>
          </tr>
          <tr>
            <td>Custom secret store</td>
            <td><code>plugin</code></td>
            <td>Any store via JSON protocol</td>
          </tr>
          <tr>
            <td>Team with shared secrets</td>
            <td><code>keychain</code> per-developer + <code>sync push/pull</code></td>
            <td>Each dev has own keychain, sync via git</td>
          </tr>
        </tbody>
      </table>

      <p>For most development workflows, the default keychain backend is sufficient. Add cloud backends when secrets need to be shared across infrastructure or managed centrally.</p>

      <hr>

      <h2>Troubleshooting</h2>

      <h3>"keychain: secret not found"</h3>
      <p>The secret hasn't been stored yet. Run:</p>
<pre><code>envref secret set &lt;key&gt;</code></pre>

      <h3>"keychain: exec: dbus-launch: not found" (Linux)</h3>
      <p>The Secret Service API requires a D-Bus session. This is common on headless Linux systems. Switch to the vault backend:</p>
<pre><code>envref vault init</code></pre>

      <p>Then update <code>.envref.yaml</code> to use vault as the primary backend.</p>

      <h3>"vault: locked"</h3>
      <p>The vault has been locked. Unlock it:</p>
<pre><code>envref vault unlock</code></pre>

      <h3>"vault: not initialized"</h3>
      <p>Run <code>envref vault init</code> to create the vault database and set a master passphrase.</p>

      <h3>"1password: op get: ... isn't an item"</h3>
      <p>The secret hasn't been stored in 1Password yet. Run:</p>
<pre><code>envref secret set &lt;key&gt; --backend op</code></pre>

      <h3>"1password: start op: executable file not found"</h3>
      <p>The <code>op</code> CLI is not installed or not on your <code>$PATH</code>. Install it:</p>
<pre><code>brew install 1password-cli</code></pre>

      <p>Then sign in: <code>op signin</code>.</p>

      <h3>"unknown backend type"</h3>
      <p>The backend type in <code>.envref.yaml</code> is not recognized. Recognized types are: <code>keychain</code>, <code>1password</code>, <code>aws-ssm</code>, <code>oci-vault</code>, <code>hashicorp-vault</code>. For custom backends, use <code>type: plugin</code>.</p>

      <h3>AWS SSM permission errors</h3>
      <p>Ensure your IAM role has the required permissions:</p>
<pre><code>{
  "Effect": "Allow",
  "Action": [
    "ssm:GetParameter",
    "ssm:PutParameter",
    "ssm:DeleteParameter",
    "ssm:GetParametersByPath"
  ],
  "Resource": "arn:aws:ssm:*:*:parameter/myapp/*"
}</code></pre>

      <h3>HashiCorp Vault authentication errors</h3>
      <p>Ensure <code>VAULT_ADDR</code> and <code>VAULT_TOKEN</code> are set, or run <code>vault login</code>:</p>
<pre><code>export VAULT_ADDR="https://vault.example.com:8200"
vault login</code></pre>

      <h3>Checking overall secret status</h3>
<pre><code>envref status</code></pre>

      <p>This shows which references are resolved, which are missing, and provides actionable hints for fixing issues.</p>

      <div class="see-also">
        <h2>See also</h2>
        <ul>
          <li><a href="getting-started.html">Getting Started</a> <span>— basic envref setup</span></li>
          <li><a href="profiles.html">Profiles</a> <span>— profile-scoped secrets</span></li>
          <li><a href="direnv-integration.html">direnv Integration</a> <span>— automatic environment loading</span></li>
        </ul>
      </div>
    </main>
  </div>

  <footer>
    <div class="footer-links">
      <a href="https://github.com/xcke/envref">GitHub</a>
      <a href="https://github.com/xcke/envref/releases">Releases</a>
      <a href="getting-started.html">Docs</a>
      <a href="https://github.com/xcke/envref/blob/main/LICENSE">MIT License</a>
    </div>
    <p>envref — separate config from secrets</p>
  </footer>
</body>
</html>
